// Generated by CoffeeScript 2.7.0
(function() {
  var CONFIG_FILE, CONFIG_PATH, CWD, argv, checkCoffee, checkLatest, compile, consola, crypto, exec, executePlugins, fs, getCompiledFiles, hideBin, isPackageLatest, path, pkg, runPlugins, setup, spawn, yargs;

  yargs = require('yargs');

  ({hideBin} = require('yargs/helpers'));

  consola = require('consola');

  ({isPackageLatest} = require('is-package-latest'));

  fs = require('fs');

  path = require('path');

  ({exec, spawn} = require('child_process'));

  crypto = require('crypto');

  pkg = require('../package.json');

  CWD = process.cwd();

  CONFIG_FILE = 'coffee.config.cjs';

  CONFIG_PATH = path.join(CWD, CONFIG_FILE);

  // async
  checkLatest = async function() {
    var res;
    try {
      res = (await isPackageLatest(pkg));
      if (res.success && !res.isLatest) {
        return consola.box(`A new version is available!\n\n${res.currentVersion} --> \`${res.latestVersion}\``);
      }
    } catch (error1) {
      return null;
    }
  };

  checkCoffee = function() {
    var PKG_PATH, error, pkgData, pkgFile, ref, ref1;
    PKG_PATH = path.join(CWD, 'package.json');
    if (fs.existsSync(PKG_PATH)) {
      try {
        pkgFile = fs.readFileSync(PKG_PATH, 'utf-8');
        pkgData = JSON.parse(pkgFile);
        if (((ref = pkgData.dependencies) != null ? ref.coffeescript : void 0) || ((ref1 = pkgData.devDependencies) != null ? ref1.coffeescript : void 0)) {
          return;
        }
      } catch (error1) {
        error = error1;
        consola.warn(`Could not parse \`package.json\`: ${error.message}`);
      }
    }
    return exec('coffee --version', function(error) {
      if (error) {
        consola.warn('CoffeeScript is not found in local dependencies (`dependencies`, `devDependencies`) or globally.');
        return consola.info('Please install it via `npm install --save-dev coffeescript` to continue.');
      }
    });
  };

  // async
  setup = async function() {
    var CONFIG_TEMPLATE, TEMPLATE_PATH, check, error, pstat, stat;
    checkCoffee();
    pstat = "created";
    stat = "create";
    if (fs.existsSync(CONFIG_PATH)) {
      consola.warn(`\`${CONFIG_FILE}\` already exists in this directory.`);
      check = (await consola.prompt(`Do you want to reset \`${CONFIG_FILE}\`?`, {
        type: "confirm"
      }));
      if (!check) {
        consola.info("Cancelled.");
        return;
      } else {
        fs.rmSync(CONFIG_PATH, {
          recursive: true,
          force: true
        });
        pstat = "reset";
        stat = "reset";
      }
    }
    try {
      TEMPLATE_PATH = path.join(__dirname, '..', 'temp', CONFIG_FILE);
      CONFIG_TEMPLATE = fs.readFileSync(TEMPLATE_PATH, 'utf-8');
      fs.writeFileSync(CONFIG_PATH, CONFIG_TEMPLATE);
      return consola.success(`Successfully ${pstat} \`${CONFIG_FILE}\`!`);
    } catch (error1) {
      error = error1;
      consola.error(`Failed to ${stat} \`${CONFIG_FILE}\`:`, error);
      return consola.info(`Template file may be missing from the package installation at \`${TEMPLATE_PATH}\``);
    }
  };

  getCompiledFiles = function(targetPath) {
    var error, filesList, i, item, itemPath, items, len, stat;
    filesList = [];
    if (!fs.existsSync(targetPath)) {
      consola.warn(`Path does not exist, skipping scan ${targetPath}`);
      return [];
    }
    try {
      stat = fs.statSync(targetPath);
      if (stat.isDirectory()) {
        consola.start(`Scanning directory: ${targetPath}`);
        items = fs.readdirSync(targetPath);
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          itemPath = path.join(targetPath, item);
          filesList = filesList.concat(getCompiledFiles(itemPath));
        }
      } else if (stat.isFile()) {
        if (targetPath.endsWith('.js' || targetPath.endsWith('.js.map'))) {
          if (fs.existsSync(targetPath)) {
            consola.info(`Found file: \`${targetPath}\``);
          }
          filesList.push(targetPath);
        }
      }
    } catch (error1) {
      error = error1;
      consola.warn(`Could not scan output path ${targetPath}: ${error.message}`);
    }
    return filesList;
  };

  executePlugins = function(config, compilationResult) {
    var plugins, ref;
    plugins = ((ref = config.milkee) != null ? ref.plugins : void 0) || [];
    if (!(plugins.length > 0)) {
      return;
    }
    consola.start(`Running ${plugins.length} plugin(s)...`);
    return (async function() {      // async
      var error, i, len, pluginFn;
      try {
        for (i = 0, len = plugins.length; i < len; i++) {
          pluginFn = plugins[i];
          if (typeof pluginFn === 'function') {
            await Promise.resolve(pluginFn(compilationResult));
          } else {
            consola.warn(`Invalid plugin definition skipped (expected a function, got ${typeof pluginFn}).`);
          }
        }
        return consola.success("Plugins executed successfully.");
      } catch (error1) {
        error = error1;
        return consola.error("An error occurred during plugin execution:", error);
      }
    })();
  };

  runPlugins = function(config, options, stdout = '', stderr = '') {
    var compilationResult, compiledFiles, mapPath, outputPath;
    outputPath = path.join(CWD, config.output);
    compiledFiles = getCompiledFiles(outputPath);
    if (options.join && options.map && !options.inlineMap) {
      mapPath = `${outputPath}.map`;
      if (fs.existsSync(mapPath && !compiledFiles.includes(mapPath))) {
        compiledFiles = compiledFiles.concat(getCompiledFiles(mapPath));
      }
    }
    compilationResult = {
      config: config,
      compiledFiles: compiledFiles,
      stdout: stdout,
      stderr: stderr
    };
    return executePlugins(config, compilationResult);
  };

  // async
  compile = async function() {
    var backupFiles, backupName, backupPath, clearBackups, compilerProcess, config, debounceTimeout, dirName, enabledOptions, enabledOptionsList, error, execCommand, execCommandParts, execOtherOptionStrings, fileName, hash, i, item, items, lastError, len, milkee, milkeeOptions, options, originalPath, restoreBackups, spawnArgs, stat, summary, targetDir, toContinue;
    await checkLatest();
    checkCoffee();
    if (!fs.existsSync(CONFIG_PATH)) {
      consola.error(`\`${CONFIG_FILE}\` not found in this directory: ${CWD}`);
      consola.info('Please run `milkee --setup` to create a configuration file.');
      process.exit(1);
    }
    try {
      config = require(CONFIG_PATH);
      if (!(config.entry && config.output)) {
        consola.error('`entry` and `output` properties are required in your configuration.');
        process.exit(1);
      }
      options = {...(config.options || {})};
      milkee = config.milkee || {};
      milkeeOptions = config.milkee.options || {};
      execCommandParts = ['coffee'];
      if (options.join) {
        execCommandParts.push('--join');
        execCommandParts.push(`\"${config.output}\"`);
      } else {
        execCommandParts.push('--output');
        execCommandParts.push(`\"${config.output}\"`);
      }
      execOtherOptionStrings = [];
      if (options.bare) {
        execOtherOptionStrings.push('--bare');
      }
      if (options.map) {
        execOtherOptionStrings.push('--map');
      }
      if (options.inlineMap) {
        execOtherOptionStrings.push('--inline-map');
      }
      if (options.noHeader) {
        execOtherOptionStrings.push('--no-header');
      }
      if (options.transpile) {
        execOtherOptionStrings.push('--transpile');
      }
      if (options.literate) {
        execOtherOptionStrings.push('--literate');
      }
      if (execOtherOptionStrings.length > 0) {
        execCommandParts.push(execOtherOptionStrings.join(' '));
      }
      execCommandParts.push('--compile');
      execCommandParts.push(`\"${config.entry}\"`);
      execCommand = execCommandParts.filter(Boolean).join(' ');
      spawnArgs = [];
      if (options.join) {
        spawnArgs.push('--join');
        spawnArgs.push(config.output);
      } else {
        spawnArgs.push('--output');
        spawnArgs.push(config.output);
      }
      if (options.bare) {
        spawnArgs.push('--bare');
      }
      if (options.map) {
        spawnArgs.push('--map');
      }
      if (options.inlineMap) {
        spawnArgs.push('--inline-map');
      }
      if (options.noHeader) {
        spawnArgs.push('--no-header');
      }
      if (options.transpile) {
        spawnArgs.push('--transpile');
      }
      if (options.literate) {
        spawnArgs.push('--literate');
      }
      if (options.watch) {
        spawnArgs.push('--watch');
      }
      spawnArgs.push('--compile');
      spawnArgs.push(config.entry);
      summary = [];
      summary.push(`Entry: \`${config.entry}\``);
      summary.push(`Output: \`${config.output}\``);
      enabledOptions = Object.keys(options).filter(function(key) {
        return options[key];
      });
      if (enabledOptions.length > 0) {
        enabledOptionsList = enabledOptions.join(',');
        summary.push(`Options: ${enabledOptionsList}`);
      }
      consola.box({
        title: "Milkee Compilation Summary",
        message: summary.join('\n')
      });
      if (milkeeOptions.confirm) {
        toContinue = (await consola.prompt("Do you want to continue?", {
          type: "confirm"
        }));
        if (!toContinue) {
          consola.info("Canceled.");
          return;
        }
      }
      delete options.join;
      backupFiles = [];
      restoreBackups = function() {
        var backup, e, i, len;
        consola.info("Restoring previous files...");
        if (backupFiles.length > 0) {
          for (i = 0, len = backupFiles.length; i < len; i++) {
            backup = backupFiles[i];
            try {
              if (fs.existsSync(backup.original)) {
                fs.rmSync(backup.original, {
                  force: true
                });
              }
              if (fs.existsSync(backup.backup)) {
                fs.renameSync(backup.backup, backup.original);
              }
            } catch (error1) {
              e = error1;
              consola.warn(`Failed to restore ${backup.original}`);
            }
          }
          return consola.success("Restored!");
        } else {
          return consola.info("No files found to restore.");
        }
      };
      clearBackups = function() {
        var backup, e, i, len, results;
        if (backupFiles.length > 0) {
          consola.start("Cleaning up backups...");
          results = [];
          for (i = 0, len = backupFiles.length; i < len; i++) {
            backup = backupFiles[i];
            try {
              if (fs.existsSync(backup.backup)) {
                results.push(fs.rmSync(backup.backup, {
                  force: true
                }));
              } else {
                results.push(void 0);
              }
            } catch (error1) {
              e = error1;
              results.push(null);
            }
          }
          return results;
        }
      };
      if (milkeeOptions.refresh) {
        targetDir = path.join(CWD, config.output);
        if (fs.existsSync(targetDir)) {
          stat = fs.statSync(targetDir);
          hash = crypto.randomBytes(4).toString('hex');
          try {
            if (stat.isDirectory()) {
              consola.info("Executing: Refresh");
              items = fs.readdirSync(targetDir);
              consola.start("Bucking up files...");
              for (i = 0, len = items.length; i < len; i++) {
                item = items[i];
                originalPath = path.join(targetDir, item);
                backupName = `${hash}.${item}.bak`;
                backupPath = path.join(targetDir, backupName);
                fs.renameSync(originalPath, backupPath);
                backupFiles.push({
                  original: originalPath,
                  backup: backupPath
                });
              }
              // itemPath = path.join targetDir, item
              // fs.rmSync itemPath, recursive: true, force: true
              consola.success(`Files backed up with hash \`${hash}\``);
            } else {
              // consola.success "Refreshed!"
              consola.info("Executing: Refresh (Single File)");
              originalPath = targetDir;
              fileName = path.basename(originalPath);
              dirName = path.dirname(originalPath);
              backupName = `${hash}.${fileName}.bak`;
              backupPath = path.join(dirName, backupName);
              fs.renameSync(originalPath, backupPath);
              backupFiles.push({
                original: originalPath,
                backup: backupPath
              });
              consola.success(`Existing file backed up as \`${backupName}\``);
            }
          } catch (error1) {
            // fs.rmSync targetDir, force: true
            // consola.success "Refreshed!"
            error = error1;
            consola.error("Failed to create backups during refresh:", error);
            restoreBackups();
            process.exit(1);
          }
        } else {
          consola.info("Refresh skipped.");
        }
      }
      if (options.watch) {
        consola.start(`Watching for changes in \`${config.entry}\`...`);
        consola.info(`Executing: coffee ${spawnArgs.join(' ')}`);
        if (milkeeOptions.refresh) {
          consola.warn("Refresh backup is disabled in watch mode (backups are cleared immediately).");
          clearBackups();
        }
        compilerProcess = spawn('coffee', spawnArgs, {
          shell: true
        });
        debounceTimeout = null;
        lastError = null;
        compilerProcess.stderr.on('data', function(data) {
          var errorMsg;
          errorMsg = data.toString().trim();
          if (errorMsg) {
            consola.error(errorMsg);
            return lastError = errorMsg;
          }
        });
        compilerProcess.stdout.on('data', function(data) {
          var stdoutMsg;
          stdoutMsg = data.toString().trim();
          if (stdoutMsg) {
            consola.log(stdoutMsg);
          }
          debounceTimeout = null;
          lastError = null;
          if (debounceTimeout) {
            clearTimeout(debounceTimeout);
          }
          return debounceTimeout = setTimeout(function() {
            if (lastError) {
              consola.warn("Compilation failed, plugins skipped.");
            } else {
              consola.success('Compilation successful (watch mode).');
              runPlugins(config, {...(config.options || {})}, '(watch mode)', '');
            }
            return lastError = null;
          }, 100);
        });
        compilerProcess.on('close', function(code) {
          return consola.info(`Watch process exited with code ${code}.`);
        });
        return compilerProcess.on('error', function(err) {
          consola.error('Failed to start watch process:', err);
          return process.exit(1);
        });
      } else {
        consola.start(`Compiling from \`${config.entry}\` to \`${config.output}\`...`);
        consola.info(`Executing: ${execCommand}`);
        return compilerProcess = exec(execCommand, function(error, stdout, stderr) {
          if (error) {
            consola.error('Compilation failed:', error);
            if (stderr) {
              consola.error(stderr.toString().trim());
            }
            if (milkeeOptions.refresh) {
              restoreBackups();
            }
            process.exit(1);
            return;
          }
          setTimeout(function() {
            if (milkeeOptions.refresh) {
              clearBackups();
              consola.success('Backup clearing completed!');
            }
            return consola.success('Compilation completed successfully!');
          }, 500);
          if (stdout) {
            process.stdout.write(stdout);
          }
          if (stderr && !error) {
            process.stderr.write(stderr);
          }
          return runPlugins(config, {...(config.options || {})}, stdout, stderr);
        });
      }
    } catch (error1) {
      error = error1;
      consola.error('Failed to load or execute configuration:', error);
      return process.exit(1);
    }
  };

  argv = yargs(hideBin(process.argv)).scriptName('milkee').usage('$0 [command]').option('setup', {
    alias: 's',
    describe: `Generate a default ${CONFIG_FILE}`,
    type: 'boolean'
  }).option('compile', {
    alias: 'c',
    describe: `Compile CoffeeScript based on ${CONFIG_FILE} (default)`,
    type: 'boolean'
  }).version('version', pkg.version).alias('v', 'version').help('help').alias('h', 'help').argv;

  if (argv.setup) {
    setup();
  } else {
    compile();
  }

}).call(this);
